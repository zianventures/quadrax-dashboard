<script>
/**
 * QuadraX Live EUR/USD Demo Driver
 * - Static-site friendly (GitHub Pages / Netlify)
 * - Pulls live EURUSD spot via public JSON endpoints
 * - Computes rolling features and classifies 8 market states
 * - Updates existing dashboard DOM IDs from the polished version
 *
 * NOTE:
 * - This is a demo regime engine to make the dashboard react to live price.
 * - Portfolio metrics remain placeholders until MT4/MT5 integration.
 */

// ----------------------------
// Live FX endpoints (with fallback)
// ----------------------------
// Primary (often CORS-friendly):
const FEED_PRIMARY = "https://api.exchangerate.host/latest?base=EUR&symbols=USD";
// Backup 1:
const FEED_BACKUP_1 = "https://open.er-api.com/v6/latest/EUR"; // returns rates.USD
// Backup 2:
const FEED_BACKUP_2 = "https://api.frankfurter.app/latest?from=EUR&to=USD"; // rates.USD

const POLL_MS = 5000;        // 5s polling for demo
const WINDOW = 60;           // rolling window length (samples)
const MAX_BUF = WINDOW * 4;  // buffer cap

// ----------------------------
// State dictionary
// ----------------------------
const stateNames = {
  1: "Mean-Reverting",
  2: "Liquidity Vacuum",
  3: "Slow Drift",
  4: "Strong Trend",
  5: "Stop Cascade",
  6: "News Shock",
  7: "Dealer Unwind",
  8: "Panic/Forced"
};

// ----------------------------
// Demo portfolio placeholders (until MT4 live)
// ----------------------------
let accountBalance = 1000000;
let totalExposure = 650000;
let dailyPnL = 12500;
let maxDrawdown = -3.2;

let var95 = 28500;
let cvar95 = 42300;
let correlation = 0.32;
let corrMax = 0.5;
let beta = 0.15;

// ----------------------------
// Live system state
// ----------------------------
let isLive = true;

let currentState = 1;
let stateConfidence = 0.82;
let stateHistory = [1,1,1,2,1,1,1,1,3,3,3,1];

// Rolling buffers
const prices = [];
const rets = [];

// Alerts
let alerts = [
  { severity: "warning", message: "Live feed integration active. Regime engine warming up.", time: "Just now" },
  { severity: "info", message: "Portfolio and risk tiles are placeholders until MT4 integration.", time: "Just now" }
];

// ----------------------------
// Utility
// ----------------------------
function fmtUsd(x){
  return x.toLocaleString(undefined, { style:"currency", currency:"USD" });
}
function fmtPct(x){
  return (x * 100).toFixed(1) + "%";
}
function nowTime(){
  return new Date().toLocaleTimeString();
}
function clamp(x, a, b){
  return Math.max(a, Math.min(b, x));
}
function safeNum(x){
  const n = Number(x);
  return Number.isFinite(n) ? n : null;
}

// Std dev
function calcStd(arr){
  if (arr.length < 2) return 0;
  const mean = arr.reduce((s,v)=>s+v,0) / arr.length;
  const v = arr.reduce((s,x)=>s + (x-mean)*(x-mean),0) / (arr.length - 1);
  return Math.sqrt(v);
}

// Regression slope on indices 0..n-1
function calcSlope(series){
  const n = series.length;
  if (n < 3) return 0;
  let sumX=0, sumY=0, sumXY=0, sumXX=0;
  for (let i=0; i<n; i++){
    const x = i;
    const y = series[i];
    sumX += x; sumY += y; sumXY += x*y; sumXX += x*x;
  }
  const denom = (n * sumXX - sumX * sumX);
  if (denom === 0) return 0;
  return (n * sumXY - sumX * sumY) / denom;
}

// ----------------------------
// DOM helpers (matches your polished dashboard IDs)
// ----------------------------
function $(id){ return document.getElementById(id); }

function setText(id, txt){
  const el = $(id);
  if (el) el.textContent = txt;
}

function setHTML(id, html){
  const el = $(id);
  if (el) el.innerHTML = html;
}

function setLiveUI(){
  const dot = $("liveDot");
  const txt = $("liveText");
  const sys = $("sysStatus");
  const pauseBtn = $("pauseBtn");

  if (dot) dot.className = isLive ? "dot" : "dot off";
  if (txt) txt.textContent = isLive ? "LIVE" : "PAUSED";
  if (sys) sys.textContent = isLive ? "LIVE" : "PAUSED";
  if (pauseBtn) pauseBtn.textContent = isLive ? "Pause" : "Resume";
}

// alert severity class mapping
function sevClass(sev){
  if (sev === "critical") return "sev-critical";
  if (sev === "warning") return "sev-warn";
  return "sev-info";
}

function pushAlert(severity, message){
  alerts.unshift({ severity, message, time: "Just now" });
  alerts = alerts.slice(0, 8);
}

// probability bar colors
function stateColor(s){
  if (s===1) return "rgba(52,211,153,0.95)";
  if (s===2) return "rgba(245,158,11,0.95)";
  if (s===3) return "rgba(96,165,250,0.95)";
  if (s===4) return "rgba(59,130,246,0.95)";
  if (s===5) return "rgba(251,146,60,0.95)";
  if (s===6) return "rgba(248,113,113,0.95)";
  if (s===7) return "rgba(167,139,250,0.95)";
  return "rgba(239,68,68,0.95)";
}

// risk level from state + a couple metrics
function riskLevel(){
  if (currentState >= 7) return "CRITICAL";
  if (currentState >= 5) return "HIGH";
  if (currentState === 2) return "ELEVATED";
  return "NORMAL";
}

function riskColor(level){
  if (level === "NORMAL") return "rgba(16,185,129,0.20)";
  if (level === "ELEVATED") return "rgba(245,158,11,0.22)";
  if (level === "HIGH") return "rgba(249,115,22,0.22)";
  return "rgba(220,38,38,0.22)";
}

// ----------------------------
// Render UI
// ----------------------------
function render(){
  setText("lastUpdate", nowTime());

  // state panel
  setText("stateName", `STATE ${currentState}: ${stateNames[currentState]}`);
  setText("confidence", fmtPct(stateConfidence));
  setText("stateBadge", String(currentState));
  setText("sysRegime", `State ${currentState}`);

  // history chips
  const hist = $("stateHistory");
  if (hist){
    hist.innerHTML = "";
    stateHistory.forEach((s, idx) => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.textContent = String(s);
      chip.title = stateNames[s];
      chip.style.opacity = String(0.35 + (idx / Math.max(1, stateHistory.length-1)) * 0.65);
      chip.style.borderColor = stateColor(s).replace("0.95","0.35");
      hist.appendChild(chip);
    });
  }

  // probabilities
  const probList = $("probList");
  if (probList){
    probList.innerHTML = "";
    // sorted high to low
    const entries = Object.entries(stateProbabilities).map(([k,v]) => [Number(k), Number(v)]);
    entries.sort((a,b)=>b[1]-a[1]);

    entries.forEach(([s,p]) => {
      const row = document.createElement("div");
      row.className = "prob-row";

      const head = document.createElement("div");
      head.className = "prob-head";

      const left = document.createElement("div");
      left.textContent = `State ${s}: ${stateNames[s]}`;
      left.style.color = "rgba(230,234,242,0.88)";

      const right = document.createElement("div");
      right.textContent = `${p.toFixed(1)}%`;
      right.style.fontWeight = "900";
      right.style.color = stateColor(s);

      head.appendChild(left);
      head.appendChild(right);

      const bar = document.createElement("div");
      bar.className = "bar";
      const fill = document.createElement("div");
      fill.className = "fill";
      fill.style.width = `${clamp(p,0,100)}%`;
      fill.style.background = stateColor(s);

      bar.appendChild(fill);
      row.appendChild(head);
      row.appendChild(bar);
      probList.appendChild(row);
    });
  }

  // portfolio tiles
  setText("balance", fmtUsd(accountBalance));

  const pnlEl = $("dailyPnl");
  if (pnlEl){
    pnlEl.textContent = (dailyPnL >= 0 ? "+" : "") + fmtUsd(Math.round(dailyPnL));
    pnlEl.style.color = dailyPnL >= 0 ? "rgba(52,211,153,0.95)" : "rgba(248,113,113,0.95)";
  }

  setText("exposure", fmtUsd(totalExposure));
  setText("drawdown", `${maxDrawdown.toFixed(1)}%`);

  // risk tile + metrics
  const rl = riskLevel();
  setText("riskLevel", rl);

  const tile = $("riskTile");
  if (tile) tile.style.background = riskColor(rl);

  setText("var95", fmtUsd(var95));
  setText("varPct", fmtPct(var95 / accountBalance));
  setText("cvar95", fmtUsd(cvar95));
  setText("corr", fmtPct(correlation));
  setText("corrMax", fmtPct(corrMax));
  setText("beta", beta.toFixed(2));

  const ratio = clamp(correlation / corrMax, 0, 1);
  const corrFill = $("corrFill");
  if (corrFill){
    corrFill.style.width = `${ratio * 100}%`;
    corrFill.style.background = (correlation > corrMax) ? "rgba(245,158,11,0.95)" : "rgba(52,211,153,0.95)";
  }

  // alerts
  const aWrap = $("alerts");
  if (aWrap){
    aWrap.innerHTML = "";
    alerts.slice(0,8).forEach(a => {
      const el = document.createElement("div");
      el.className = "alert";

      const sev = document.createElement("div");
      sev.className = `sev ${sevClass(a.severity)}`;
      sev.textContent = a.severity.toUpperCase();

      const msg = document.createElement("div");
      msg.className = "msg";
      msg.textContent = a.message;

      const time = document.createElement("div");
      time.className = "time";
      time.textContent = a.time;

      el.appendChild(sev);
      el.appendChild(msg);
      el.appendChild(time);
      aWrap.appendChild(el);
    });
  }

  // footer
  setText("posCount", "5"); // placeholder until MT4
  setLiveUI();
}

// ----------------------------
// Fetch EURUSD spot (with fallbacks)
// ----------------------------
async function fetchEURUSD(){
  // Try primary
  try{
    const res = await fetch(FEED_PRIMARY, { cache:"no-store" });
    const json = await res.json();
    const px = safeNum(json?.rates?.USD);
    if (px) return px;
  } catch(e){}

  // Backup 1
  try{
    const res = await fetch(FEED_BACKUP_1, { cache:"no-store" });
    const json = await res.json();
    const px = safeNum(json?.rates?.USD);
    if (px) return px;
  } catch(e){}

  // Backup 2
  try{
    const res = await fetch(FEED_BACKUP_2, { cache:"no-store" });
    const json = await res.json();
    const px = safeNum(json?.rates?.USD);
    if (px) return px;
  } catch(e){}

  throw new Error("All EURUSD feeds failed");
}

// ----------------------------
// 8-state classifier (transparent heuristic demo)
// ----------------------------
let stateProbabilities = { 1:82, 2:8, 3:5, 4:3, 5:1, 6:0.5, 7:0.3, 8:0.2 };

function classifyRegime(){
  const r = rets.slice(Math.max(0, rets.length - WINDOW));
  const p = prices.slice(Math.max(0, prices.length - WINDOW));

  const vol = calcStd(r);
  const slope = calcSlope(p);
  const absSlope = Math.abs(slope);

  const half = Math.max(6, Math.floor(r.length/2));
  const volEarly = calcStd(r.slice(0, half));
  const volLate  = calcStd(r.slice(half));
  const volChange = volEarly > 0 ? (volLate / volEarly) : 1;

  // thresholds tuned for spot rates (small numbers)
  const lowVol = vol < 0.00006;
  const medVol = vol >= 0.00006 && vol < 0.00014;
  const hiVol  = vol >= 0.00014;

  const weakTrend = absSlope < 0.000005;
  const medTrend  = absSlope >= 0.000005 && absSlope < 0.00002;
  const strongTrend = absSlope >= 0.00002;

  let s = 1;

  // map to states
  if (lowVol && weakTrend) s = 1;
  else if (lowVol && volChange > 1.35) s = 2;
  else if (medVol && medTrend) s = 3;
  else if ((medVol || hiVol) && strongTrend) s = 4;
  else if (hiVol && volChange > 1.6 && strongTrend) s = 5;
  else if (hiVol && volChange > 1.6 && !strongTrend) s = 6;
  else if (hiVol && medTrend) s = 7;
  else if (hiVol && strongTrend && volChange > 2.0) s = 8;

  // confidence: higher with clearer vol expansion and stronger trend
  let conf = 0.62;
  conf += clamp((volChange - 1) * 0.10, 0, 0.20);
  conf += clamp(absSlope * 2500, 0, 0.13);
  conf = clamp(conf, 0.55, 0.95);

  // probabilities: place mass on current state, sprinkle structured neighbors
  const base = {1:2,2:2,3:2,4:2,5:1,6:1,7:1,8:1};
  base[s] = 70 + Math.round((conf - 0.55) * 60); // 70..94-ish

  if (s === 1) { base[2]+=6; base[3]+=4; }
  if (s === 2) { base[3]+=6; base[4]+=4; }
  if (s === 3) { base[1]+=6; base[4]+=6; }
  if (s === 4) { base[3]+=6; base[5]+=4; }
  if (s === 5) { base[4]+=6; base[8]+=6; }
  if (s === 6) { base[4]+=6; base[7]+=4; }
  if (s === 7) { base[4]+=6; base[5]+=4; }
  if (s === 8) { base[5]+=8; base[6]+=6; }

  let sum = 0;
  for (let k=1; k<=8; k++) sum += base[k];

  const probs = {};
  let running = 0;
  for (let k=1; k<=8; k++){
    probs[k] = Math.round((base[k] / sum) * 1000) / 10; // 1 decimal
    running += probs[k];
  }
  // fix rounding drift
  const drift = Math.round((100 - running) * 10) / 10;
  probs[s] = Math.round((probs[s] + drift) * 10) / 10;

  return { state: s, conf, probs, vol, slope, volChange };
}

// ----------------------------
// Main tick loop
// ----------------------------
let prevState = currentState;

async function tick(){
  if (!isLive) return;

  try{
    const px = await fetchEURUSD();

    const last = prices.length ? prices[prices.length - 1] : px;
    prices.push(px);
    if (prices.length > MAX_BUF) prices.shift();

    const r = (px - last) / last;
    rets.push(r);
    if (rets.length > MAX_BUF) rets.shift();

    // Need a few points before we trust anything
    if (prices.length < 10){
      pushAlert("info", `Warming up buffers (${prices.length}/10)…`);
      render();
      return;
    }

    const res = classifyRegime();

    prevState = currentState;
    currentState = res.state;
    stateConfidence = res.conf;
    stateProbabilities = res.probs;

    // update history
    stateHistory = stateHistory.slice(1);
    stateHistory.push(currentState);

    // portfolio reacts to volatility as a demo proxy
    const volScale = clamp(res.volChange, 0.6, 3.0);
    dailyPnL += (Math.random() - 0.5) * 900 * volScale;

    // alerts: transitions and volatility expansion
    if (currentState !== prevState){
      pushAlert("info", `Regime transition: State ${prevState} → State ${currentState} (${stateNames[currentState]}).`);
    }
    if (res.volChange > 1.8){
      pushAlert("warning", `Volatility expansion detected (x${res.volChange.toFixed(2)}). Tighten risk and consider reducing size.`);
    }
    if (currentState >= 7){
      pushAlert("critical", `Critical regime detected: State ${currentState}. Consider pausing entries and cutting exposure.`);
    }

    render();
  } catch(e){
    pushAlert("warning", "Live EUR/USD feed error. Check endpoint availability or CORS. Falling back to last known values.");
    render();
  }
}

// ----------------------------
// Wire buttons (Pause / Sync / Reduce / Flatten)
// ----------------------------
(function wireButtons(){
  const pauseBtn = $("pauseBtn");
  if (pauseBtn){
    pauseBtn.addEventListener("click", () => {
      isLive = !isLive;
      setLiveUI();
      pushAlert("info", isLive ? "System resumed (live ticks active)." : "System paused (ticks halted).");
      render();
    });
  }

  const syncBtn = $("syncBtn");
  if (syncBtn){
    syncBtn.addEventListener("click", () => {
      prices.length = 0;
      rets.length = 0;
      currentState = 1;
      prevState = 1;
      stateConfidence = 0.82;
      stateHistory = [1,1,1,2,1,1,1,1,3,3,3,1];
      stateProbabilities = { 1:82, 2:8, 3:5, 4:3, 5:1, 6:0.5, 7:0.3, 8:0.2 };
      dailyPnL = 12500;
      alerts = [
        { severity: "info", message: "Sync complete. Buffers reset. Waiting for live price samples.", time: "Just now" }
      ];
      isLive = true;
      setLiveUI();
      render();
    });
  }

  const reduceBtn = $("reduceBtn");
  if (reduceBtn){
    reduceBtn.addEventListener("click", () => {
      totalExposure = Math.round(totalExposure * 0.5);
      pushAlert("warning", "Exposure reduced 50% (demo control).");
      render();
    });
  }

  const flattenBtn = $("flattenBtn");
  if (flattenBtn){
    flattenBtn.addEventListener("click", () => {
      totalExposure = 0;
      pushAlert("critical", "Emergency flatten executed (demo control).");
      render();
    });
  }
})();

// ----------------------------
// Boot
// ----------------------------
render();
tick();
setInterval(tick, POLL_MS);
</script>
